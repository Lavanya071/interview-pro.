{"ast":null,"code":"// src/api.js\n// Fake frontend-only API: stores everything in localStorage.\n// Drop-in replacement for axios-based api used in the project.\n\nconst STORAGE_KEYS = {\n  USERS: 'fp_users',\n  QUESTIONS: 'fp_questions',\n  TOKENS: 'fp_tokens',\n  // maps token -> userId\n  VOTES: 'fp_votes',\n  // maps userId -> [questionId]\n  BOOKMARKS: 'fp_bookmarks' // maps userId -> [questionId]\n};\n\n// --- Helpers ---\nconst uid = () => Math.random().toString(36).slice(2, 9);\nconst now = () => new Date().toISOString();\nconst read = (key, fallback) => {\n  try {\n    const raw = localStorage.getItem(key);\n    return raw ? JSON.parse(raw) : fallback;\n  } catch {\n    return fallback;\n  }\n};\nconst write = (key, val) => localStorage.setItem(key, JSON.stringify(val));\n\n// init defaults if missing\n(function initDefaults() {\n  if (!read(STORAGE_KEYS.USERS, null)) {\n    // seed with one user for convenience: test@test.com / password: test123\n    write(STORAGE_KEYS.USERS, [{\n      id: 1,\n      name: 'Test User',\n      email: 'test@test.com',\n      password: 'test123',\n      createdAt: now()\n    }]);\n  }\n  if (!read(STORAGE_KEYS.QUESTIONS, null)) {\n    write(STORAGE_KEYS.QUESTIONS, [{\n      id: 1,\n      question_text: 'What is React?',\n      option_a: 'JS library',\n      option_b: 'Framework',\n      option_c: 'Language',\n      option_d: 'Database',\n      correct_option: 'A',\n      category: 'Frontend',\n      difficulty: 'Easy',\n      votes: 3,\n      created_by: 1,\n      created_at: now()\n    }, {\n      id: 2,\n      question_text: 'What is Node.js?',\n      option_a: 'JS runtime',\n      option_b: 'Framework',\n      option_c: 'Language',\n      option_d: 'Database',\n      correct_option: 'A',\n      category: 'Backend',\n      difficulty: 'Easy',\n      votes: 1,\n      created_by: 1,\n      created_at: now()\n    }]);\n  }\n  if (!read(STORAGE_KEYS.TOKENS, null)) write(STORAGE_KEYS.TOKENS, {});\n  if (!read(STORAGE_KEYS.VOTES, null)) write(STORAGE_KEYS.VOTES, {});\n  if (!read(STORAGE_KEYS.BOOKMARKS, null)) write(STORAGE_KEYS.BOOKMARKS, {});\n})();\n\n// --- token handling (used by setAuthToken) ---\nconst apiDefaults = {\n  headers: {\n    common: {}\n  }\n};\nfunction setAuthToken(token) {\n  if (token) {\n    apiDefaults.headers.common['Authorization'] = `Bearer ${token}`;\n    localStorage.setItem('token', token);\n  } else {\n    delete apiDefaults.headers.common['Authorization'];\n    localStorage.removeItem('token');\n  }\n}\n\n// helper to get current user from stored token (if valid)\nfunction getUserFromToken(token) {\n  if (!token) return null;\n  const tokens = read(STORAGE_KEYS.TOKENS, {});\n  const userId = tokens[token];\n  if (!userId) return null;\n  const users = read(STORAGE_KEYS.USERS, []);\n  return users.find(u => u.id === userId) || null;\n}\n\n// helper to pull token from saved header or localStorage\nfunction resolveTokenFromConfig() {\n  // prefer explicit header saved in apiDefaults\n  const header = apiDefaults.headers.common['Authorization'] || localStorage.getItem('token') || '';\n  const token = header.startsWith('Bearer ') ? header.split(' ')[1] : header || null;\n  return token;\n}\n\n// --- fake API object (get/post) ---\nconst api = {\n  defaults: apiDefaults,\n  // GET handler\n  get: path => {\n    return new Promise((resolve, reject) => {\n      try {\n        // GET /questions -> return list sorted by votes desc\n        if (path === '/questions') {\n          const qs = read(STORAGE_KEYS.QUESTIONS, []).slice().sort((a, b) => b.votes - a.votes);\n          return resolve({\n            data: qs\n          });\n        }\n\n        // GET /questions/:id\n        const qMatch = path.match(/^\\/questions\\/(\\d+)$/);\n        if (qMatch) {\n          const id = parseInt(qMatch[1], 10);\n          const q = read(STORAGE_KEYS.QUESTIONS, []).find(x => x.id === id);\n          if (!q) return reject({\n            response: {\n              data: {\n                msg: 'Question not found'\n              }\n            }\n          });\n          return resolve({\n            data: q\n          });\n        }\n\n        // GET /users/bookmarks\n        if (path === '/users/bookmarks') {\n          const token = resolveTokenFromConfig();\n          const user = getUserFromToken(token);\n          if (!user) return reject({\n            response: {\n              data: {\n                msg: 'Unauthorized'\n              }\n            }\n          });\n          const bookmarks = read(STORAGE_KEYS.BOOKMARKS, {})[user.id] || [];\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\n          const rows = questions.filter(q => bookmarks.includes(q.id));\n          return resolve({\n            data: rows\n          });\n        }\n\n        // default: not implemented\n        return reject({\n          response: {\n            data: {\n              msg: `GET ${path} not implemented in fake API`\n            }\n          }\n        });\n      } catch (err) {\n        return reject({\n          response: {\n            data: {\n              msg: 'Server error'\n            }\n          }\n        });\n      }\n    });\n  },\n  // POST handler\n  post: (path, body) => {\n    return new Promise((resolve, reject) => {\n      try {\n        // POST /auth/register\n        if (path === '/auth/register') {\n          const {\n            name,\n            email,\n            password\n          } = body || {};\n          if (!name || !email || !password) {\n            return reject({\n              response: {\n                data: {\n                  msg: 'Missing fields'\n                }\n              }\n            });\n          }\n          const users = read(STORAGE_KEYS.USERS, []);\n          if (users.find(u => u.email === email)) {\n            return reject({\n              response: {\n                data: {\n                  msg: 'User already exists'\n                }\n              }\n            });\n          }\n          const id = users.length ? Math.max(...users.map(u => u.id)) + 1 : 1;\n          const newUser = {\n            id,\n            name,\n            email,\n            password,\n            createdAt: now()\n          };\n          users.push(newUser);\n          write(STORAGE_KEYS.USERS, users);\n\n          // create token entry\n          const token = uid();\n          const tokens = read(STORAGE_KEYS.TOKENS, {});\n          tokens[token] = id;\n          write(STORAGE_KEYS.TOKENS, tokens);\n          return resolve({\n            data: {\n              token,\n              user: {\n                id,\n                name,\n                email\n              }\n            }\n          });\n        }\n\n        // POST /auth/login\n        if (path === '/auth/login') {\n          const {\n            email,\n            password\n          } = body || {};\n          if (!email || !password) return reject({\n            response: {\n              data: {\n                msg: 'Missing fields'\n              }\n            }\n          });\n          const users = read(STORAGE_KEYS.USERS, []);\n          const user = users.find(u => u.email === email);\n          if (!user) return reject({\n            response: {\n              data: {\n                msg: 'User not found'\n              }\n            }\n          });\n          // NOTE: frontend fake API stores plaintext password (no bcrypt). Compare directly.\n          if (user.password !== password) return reject({\n            response: {\n              data: {\n                msg: 'Invalid credentials'\n              }\n            }\n          });\n          const token = uid();\n          const tokens = read(STORAGE_KEYS.TOKENS, {});\n          tokens[token] = user.id;\n          write(STORAGE_KEYS.TOKENS, tokens);\n          return resolve({\n            data: {\n              token,\n              user: {\n                id: user.id,\n                name: user.name,\n                email: user.email\n              }\n            }\n          });\n        }\n\n        // POST /questions (add new question) - requires auth\n        if (path === '/questions') {\n          const token = resolveTokenFromConfig();\n          const user = getUserFromToken(token);\n          if (!user) return reject({\n            response: {\n              data: {\n                msg: 'Unauthorized'\n              }\n            }\n          });\n          const {\n            question_text,\n            option_a,\n            option_b,\n            option_c,\n            option_d,\n            correct_option,\n            category,\n            difficulty\n          } = body || {};\n          if (!question_text || !option_a || !option_b || !option_c || !option_d || !correct_option) return reject({\n            response: {\n              data: {\n                msg: 'Missing fields'\n              }\n            }\n          });\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\n          const newId = questions.length ? Math.max(...questions.map(q => q.id)) + 1 : 1;\n          const newQ = {\n            id: newId,\n            question_text,\n            option_a,\n            option_b,\n            option_c,\n            option_d,\n            correct_option,\n            category: category || 'General',\n            difficulty: difficulty || 'Medium',\n            votes: 0,\n            created_by: user.id,\n            created_at: now()\n          };\n          questions.push(newQ);\n          write(STORAGE_KEYS.QUESTIONS, questions);\n          return resolve({\n            data: {\n              msg: 'Question added',\n              id: newId\n            }\n          });\n        }\n\n        // POST /questions/:id/vote\n        const voteMatch = path.match(/^\\/questions\\/(\\d+)\\/vote$/);\n        if (voteMatch) {\n          const qId = parseInt(voteMatch[1], 10);\n          const token = resolveTokenFromConfig();\n          const user = getUserFromToken(token);\n          if (!user) return reject({\n            response: {\n              data: {\n                msg: 'Unauthorized'\n              }\n            }\n          });\n          const votes = read(STORAGE_KEYS.VOTES, {});\n          const userVotes = votes[user.id] || [];\n          if (userVotes.includes(qId)) return reject({\n            response: {\n              data: {\n                msg: 'Already voted'\n              }\n            }\n          });\n          userVotes.push(qId);\n          votes[user.id] = userVotes;\n          write(STORAGE_KEYS.VOTES, votes);\n\n          // increment question votes\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\n          const q = questions.find(x => x.id === qId);\n          if (!q) return reject({\n            response: {\n              data: {\n                msg: 'Question not found'\n              }\n            }\n          });\n          q.votes = (q.votes || 0) + 1;\n          write(STORAGE_KEYS.QUESTIONS, questions);\n          return resolve({\n            data: {\n              msg: 'Voted successfully'\n            }\n          });\n        }\n\n        // POST /users/bookmark\n        if (path === '/users/bookmark') {\n          const token = resolveTokenFromConfig();\n          const user = getUserFromToken(token);\n          if (!user) return reject({\n            response: {\n              data: {\n                msg: 'Unauthorized'\n              }\n            }\n          });\n          const {\n            questionId\n          } = body || {};\n          if (!questionId) return reject({\n            response: {\n              data: {\n                msg: 'Missing questionId'\n              }\n            }\n          });\n          const bookmarks = read(STORAGE_KEYS.BOOKMARKS, {});\n          const userBm = bookmarks[user.id] || [];\n          if (userBm.includes(questionId)) return reject({\n            response: {\n              data: {\n                msg: 'Already bookmarked'\n              }\n            }\n          });\n          userBm.push(questionId);\n          bookmarks[user.id] = userBm;\n          write(STORAGE_KEYS.BOOKMARKS, bookmarks);\n          return resolve({\n            data: {\n              msg: 'Bookmarked'\n            }\n          });\n        }\n\n        // default: not implemented\n        return reject({\n          response: {\n            data: {\n              msg: `POST ${path} not implemented in fake API`\n            }\n          }\n        });\n      } catch (err) {\n        return reject({\n          response: {\n            data: {\n              msg: 'Server error'\n            }\n          }\n        });\n      }\n    });\n  }\n};\n\n// Export\nexport { setAuthToken };\nexport default api;","map":{"version":3,"names":["STORAGE_KEYS","USERS","QUESTIONS","TOKENS","VOTES","BOOKMARKS","uid","Math","random","toString","slice","now","Date","toISOString","read","key","fallback","raw","localStorage","getItem","JSON","parse","write","val","setItem","stringify","initDefaults","id","name","email","password","createdAt","question_text","option_a","option_b","option_c","option_d","correct_option","category","difficulty","votes","created_by","created_at","apiDefaults","headers","common","setAuthToken","token","removeItem","getUserFromToken","tokens","userId","users","find","u","resolveTokenFromConfig","header","startsWith","split","api","defaults","get","path","Promise","resolve","reject","qs","sort","a","b","data","qMatch","match","parseInt","q","x","response","msg","user","bookmarks","questions","rows","filter","includes","err","post","body","length","max","map","newUser","push","newId","newQ","voteMatch","qId","userVotes","questionId","userBm"],"sources":["C:/Users/91917/interview/frontend/src/api.js"],"sourcesContent":["// src/api.js\r\n// Fake frontend-only API: stores everything in localStorage.\r\n// Drop-in replacement for axios-based api used in the project.\r\n\r\nconst STORAGE_KEYS = {\r\n  USERS: 'fp_users',\r\n  QUESTIONS: 'fp_questions',\r\n  TOKENS: 'fp_tokens', // maps token -> userId\r\n  VOTES: 'fp_votes', // maps userId -> [questionId]\r\n  BOOKMARKS: 'fp_bookmarks' // maps userId -> [questionId]\r\n};\r\n\r\n// --- Helpers ---\r\nconst uid = () => Math.random().toString(36).slice(2, 9);\r\nconst now = () => new Date().toISOString();\r\n\r\nconst read = (key, fallback) => {\r\n  try {\r\n    const raw = localStorage.getItem(key);\r\n    return raw ? JSON.parse(raw) : fallback;\r\n  } catch {\r\n    return fallback;\r\n  }\r\n};\r\nconst write = (key, val) => localStorage.setItem(key, JSON.stringify(val));\r\n\r\n// init defaults if missing\r\n(function initDefaults() {\r\n  if (!read(STORAGE_KEYS.USERS, null)) {\r\n    // seed with one user for convenience: test@test.com / password: test123\r\n    write(STORAGE_KEYS.USERS, [\r\n      { id: 1, name: 'Test User', email: 'test@test.com', password: 'test123', createdAt: now() }\r\n    ]);\r\n  }\r\n  if (!read(STORAGE_KEYS.QUESTIONS, null)) {\r\n    write(STORAGE_KEYS.QUESTIONS, [\r\n      {\r\n        id: 1,\r\n        question_text: 'What is React?',\r\n        option_a: 'JS library',\r\n        option_b: 'Framework',\r\n        option_c: 'Language',\r\n        option_d: 'Database',\r\n        correct_option: 'A',\r\n        category: 'Frontend',\r\n        difficulty: 'Easy',\r\n        votes: 3,\r\n        created_by: 1,\r\n        created_at: now()\r\n      },\r\n      {\r\n        id: 2,\r\n        question_text: 'What is Node.js?',\r\n        option_a: 'JS runtime',\r\n        option_b: 'Framework',\r\n        option_c: 'Language',\r\n        option_d: 'Database',\r\n        correct_option: 'A',\r\n        category: 'Backend',\r\n        difficulty: 'Easy',\r\n        votes: 1,\r\n        created_by: 1,\r\n        created_at: now()\r\n      }\r\n    ]);\r\n  }\r\n  if (!read(STORAGE_KEYS.TOKENS, null)) write(STORAGE_KEYS.TOKENS, {}); \r\n  if (!read(STORAGE_KEYS.VOTES, null)) write(STORAGE_KEYS.VOTES, {});\r\n  if (!read(STORAGE_KEYS.BOOKMARKS, null)) write(STORAGE_KEYS.BOOKMARKS, {});\r\n})();\r\n\r\n// --- token handling (used by setAuthToken) ---\r\nconst apiDefaults = { headers: { common: {} } };\r\nfunction setAuthToken(token) {\r\n  if (token) {\r\n    apiDefaults.headers.common['Authorization'] = `Bearer ${token}`;\r\n    localStorage.setItem('token', token);\r\n  } else {\r\n    delete apiDefaults.headers.common['Authorization'];\r\n    localStorage.removeItem('token');\r\n  }\r\n}\r\n\r\n// helper to get current user from stored token (if valid)\r\nfunction getUserFromToken(token) {\r\n  if (!token) return null;\r\n  const tokens = read(STORAGE_KEYS.TOKENS, {});\r\n  const userId = tokens[token];\r\n  if (!userId) return null;\r\n  const users = read(STORAGE_KEYS.USERS, []);\r\n  return users.find(u => u.id === userId) || null;\r\n}\r\n\r\n// helper to pull token from saved header or localStorage\r\nfunction resolveTokenFromConfig() {\r\n  // prefer explicit header saved in apiDefaults\r\n  const header = apiDefaults.headers.common['Authorization'] || localStorage.getItem('token') || '';\r\n  const token = header.startsWith('Bearer ') ? header.split(' ')[1] : header || null;\r\n  return token;\r\n}\r\n\r\n// --- fake API object (get/post) ---\r\nconst api = {\r\n  defaults: apiDefaults,\r\n\r\n  // GET handler\r\n  get: (path) => {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        // GET /questions -> return list sorted by votes desc\r\n        if (path === '/questions') {\r\n          const qs = read(STORAGE_KEYS.QUESTIONS, []).slice().sort((a,b)=>b.votes - a.votes);\r\n          return resolve({ data: qs });\r\n        }\r\n\r\n        // GET /questions/:id\r\n        const qMatch = path.match(/^\\/questions\\/(\\d+)$/);\r\n        if (qMatch) {\r\n          const id = parseInt(qMatch[1], 10);\r\n          const q = (read(STORAGE_KEYS.QUESTIONS, [])).find(x => x.id === id);\r\n          if (!q) return reject({ response: { data: { msg: 'Question not found' } } });\r\n          return resolve({ data: q });\r\n        }\r\n\r\n        // GET /users/bookmarks\r\n        if (path === '/users/bookmarks') {\r\n          const token = resolveTokenFromConfig();\r\n          const user = getUserFromToken(token);\r\n          if (!user) return reject({ response: { data: { msg: 'Unauthorized' } } });\r\n          const bookmarks = read(STORAGE_KEYS.BOOKMARKS, {})[user.id] || [];\r\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\r\n          const rows = questions.filter(q => bookmarks.includes(q.id));\r\n          return resolve({ data: rows });\r\n        }\r\n\r\n        // default: not implemented\r\n        return reject({ response: { data: { msg: `GET ${path} not implemented in fake API` } } });\r\n      } catch (err) {\r\n        return reject({ response: { data: { msg: 'Server error' } } });\r\n      }\r\n    });\r\n  },\r\n\r\n  // POST handler\r\n  post: (path, body) => {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        // POST /auth/register\r\n        if (path === '/auth/register') {\r\n          const { name, email, password } = body || {};\r\n          if (!name || !email || !password) {\r\n            return reject({ response: { data: { msg: 'Missing fields' } } });\r\n          }\r\n          const users = read(STORAGE_KEYS.USERS, []);\r\n          if (users.find(u => u.email === email)) {\r\n            return reject({ response: { data: { msg: 'User already exists' } } });\r\n          }\r\n          const id = users.length ? Math.max(...users.map(u => u.id)) + 1 : 1;\r\n          const newUser = { id, name, email, password, createdAt: now() };\r\n          users.push(newUser);\r\n          write(STORAGE_KEYS.USERS, users);\r\n\r\n          // create token entry\r\n          const token = uid();\r\n          const tokens = read(STORAGE_KEYS.TOKENS, {});\r\n          tokens[token] = id;\r\n          write(STORAGE_KEYS.TOKENS, tokens);\r\n\r\n          return resolve({ data: { token, user: { id, name, email } } });\r\n        }\r\n\r\n        // POST /auth/login\r\n        if (path === '/auth/login') {\r\n          const { email, password } = body || {};\r\n          if (!email || !password) return reject({ response: { data: { msg: 'Missing fields' } } });\r\n          const users = read(STORAGE_KEYS.USERS, []);\r\n          const user = users.find(u => u.email === email);\r\n          if (!user) return reject({ response: { data: { msg: 'User not found' } } });\r\n          // NOTE: frontend fake API stores plaintext password (no bcrypt). Compare directly.\r\n          if (user.password !== password) return reject({ response: { data: { msg: 'Invalid credentials' } } });\r\n\r\n          const token = uid();\r\n          const tokens = read(STORAGE_KEYS.TOKENS, {});\r\n          tokens[token] = user.id;\r\n          write(STORAGE_KEYS.TOKENS, tokens);\r\n\r\n          return resolve({ data: { token, user: { id: user.id, name: user.name, email: user.email } } });\r\n        }\r\n\r\n        // POST /questions (add new question) - requires auth\r\n        if (path === '/questions') {\r\n          const token = resolveTokenFromConfig();\r\n          const user = getUserFromToken(token);\r\n          if (!user) return reject({ response: { data: { msg: 'Unauthorized' } } });\r\n\r\n          const { question_text, option_a, option_b, option_c, option_d, correct_option, category, difficulty } = body || {};\r\n          if (!question_text || !option_a || !option_b || !option_c || !option_d || !correct_option)\r\n            return reject({ response: { data: { msg: 'Missing fields' } } });\r\n\r\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\r\n          const newId = questions.length ? Math.max(...questions.map(q => q.id)) + 1 : 1;\r\n          const newQ = {\r\n            id: newId,\r\n            question_text,\r\n            option_a,\r\n            option_b,\r\n            option_c,\r\n            option_d,\r\n            correct_option,\r\n            category: category || 'General',\r\n            difficulty: difficulty || 'Medium',\r\n            votes: 0,\r\n            created_by: user.id,\r\n            created_at: now()\r\n          };\r\n          questions.push(newQ);\r\n          write(STORAGE_KEYS.QUESTIONS, questions);\r\n          return resolve({ data: { msg: 'Question added', id: newId } });\r\n        }\r\n\r\n        // POST /questions/:id/vote\r\n        const voteMatch = path.match(/^\\/questions\\/(\\d+)\\/vote$/);\r\n        if (voteMatch) {\r\n          const qId = parseInt(voteMatch[1], 10);\r\n          const token = resolveTokenFromConfig();\r\n          const user = getUserFromToken(token);\r\n          if (!user) return reject({ response: { data: { msg: 'Unauthorized' } } });\r\n\r\n          const votes = read(STORAGE_KEYS.VOTES, {});\r\n          const userVotes = votes[user.id] || [];\r\n          if (userVotes.includes(qId)) return reject({ response: { data: { msg: 'Already voted' } } });\r\n\r\n          userVotes.push(qId);\r\n          votes[user.id] = userVotes;\r\n          write(STORAGE_KEYS.VOTES, votes);\r\n\r\n          // increment question votes\r\n          const questions = read(STORAGE_KEYS.QUESTIONS, []);\r\n          const q = questions.find(x => x.id === qId);\r\n          if (!q) return reject({ response: { data: { msg: 'Question not found' } } });\r\n          q.votes = (q.votes || 0) + 1;\r\n          write(STORAGE_KEYS.QUESTIONS, questions);\r\n\r\n          return resolve({ data: { msg: 'Voted successfully' } });\r\n        }\r\n\r\n        // POST /users/bookmark\r\n        if (path === '/users/bookmark') {\r\n          const token = resolveTokenFromConfig();\r\n          const user = getUserFromToken(token);\r\n          if (!user) return reject({ response: { data: { msg: 'Unauthorized' } } });\r\n\r\n          const { questionId } = body || {};\r\n          if (!questionId) return reject({ response: { data: { msg: 'Missing questionId' } } });\r\n\r\n          const bookmarks = read(STORAGE_KEYS.BOOKMARKS, {});\r\n          const userBm = bookmarks[user.id] || [];\r\n          if (userBm.includes(questionId)) return reject({ response: { data: { msg: 'Already bookmarked' } } });\r\n\r\n          userBm.push(questionId);\r\n          bookmarks[user.id] = userBm;\r\n          write(STORAGE_KEYS.BOOKMARKS, bookmarks);\r\n\r\n          return resolve({ data: { msg: 'Bookmarked' } });\r\n        }\r\n\r\n        // default: not implemented\r\n        return reject({ response: { data: { msg: `POST ${path} not implemented in fake API` } } });\r\n      } catch (err) {\r\n        return reject({ response: { data: { msg: 'Server error' } } });\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// Export\r\nexport { setAuthToken };\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}